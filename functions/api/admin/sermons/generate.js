/**
 * File Path: /functions/api/admin/sermons/generate.js
 * Handles the POST request to trigger a new sermon generation.
 */

// --- AUTH HELPERS (copy from sermons.js or create a shared module) ---
const textEncoder = new TextEncoder();
async function getHmacKey(secret) { return await crypto.subtle.importKey('raw',textEncoder.encode(secret),{ name: 'HMAC', hash: 'SHA-256' },false,['sign', 'verify']); }
async function verifyToken(token, secret) { try { if (!secret) return null; const [header, payloadB64, signatureB64] = token.split('.'); if (!header || !payloadB64 || !signatureB64) return null; const key = await getHmacKey(secret); const data = textEncoder.encode(`${header}.${payloadB64}`); const signature = Uint8Array.from(atob(signatureB64.replace(/-/g, '+').replace(/_/g, '/')), c => c.charCodeAt(0)); const isValid = await crypto.subtle.verify('HMAC', key, signature, data); if (!isValid) return null; return JSON.parse(atob(payloadB64)); } catch (e) { return null; } }
async function authFromRequest(request, env) { const h = request.headers.get('authorization') || ''; if (!h.startsWith('Bearer ')) return null; const tok = h.slice(7); return await verifyToken(tok, env.ADMIN_SECRET); }


export async function onRequest(context) {
    const { request, env, waitUntil } = context;

    // This endpoint only accepts POST requests
    if (request.method !== 'POST') {
        return new Response(JSON.stringify({ error: 'Method not allowed' }), { status: 405 });
    }

    // Protect the endpoint
    const user = await authFromRequest(request, env);
    if (!user) {
        return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 });
    }

    try {
        // Run the generation in the background so the API can respond quickly
        waitUntil(generateAndStoreSermon(env));

        return new Response(JSON.stringify({ success: true, message: 'Sermon generation started in the background.' }), {
            headers: { 'Content-Type': 'application/json' }
        });

    } catch (e) {
        console.error('Sermon generation failed:', e);
        return new Response(JSON.stringify({ error: 'Failed to trigger sermon generation.' }), { status: 500 });
    }
}

// This is where your actual sermon generation logic lives
async function generateAndStoreSermon(env) {
    console.log("Starting sermon generation...");
    // 1. --- Call your AI (e.g., Gemini) to generate title, topic, text, etc. ---
    //    (This is placeholder logic)
    const sermonTitle = "A Generated Sermon Title";
    const sermonTopic = "Faith and Works";
    const sermonText = "This is the body of the sermon, generated by an AI. It would be several paragraphs long.";
    
    // 2. --- (Optional) Generate audio ---

    // 3. --- Store the result in the MBSERMON KV store ---
    const sermonId = `sermon:${new Date().toISOString()}`;
    const sermonData = {
        id: sermonId,
        title: sermonTitle,
        topic: sermonTopic,
        text: sermonText,
        createdAt: new Date().toISOString(),
        audioData: null // Add Base64 audio string here if you have it
    };
    await env.MBSERMON.put(sermonId, JSON.stringify(sermonData));
    console.log("Sermon generation complete and stored with ID:", sermonId);
}